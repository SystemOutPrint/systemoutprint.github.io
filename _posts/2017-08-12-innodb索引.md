---
layout: post
title:  "innodb索引"
date:   2017-08-12
categories: mysql
---

## 0x01 B+树
__优点__：B+树对比二分查找树和平衡二叉树的优点有高扇出性，并且没有频繁平衡带来性能上的问题，3~4层B+树索引即可存储很多数据。B+树对比B树的优点是非叶节点可以存更多记录。而且B+树的优势是可以顺序存储，在范围查找的时候很有优势。<br>
__缺点__：B+树有个负载因子，当元素填满节点的时候，需要节点的分裂，当节点中的元素少于负载因子*元素总数的时候，需要靠旋转或者合并节点，如果是在磁盘上操作，这些都是比较耗时的。<br>
innodb能设置的索引格式只有B+树，但是会有自适应hash索引。

## 0x02 索引
__聚集索引__：也是主键索引，每张表只有一个，叶子节点是真正存数据的，而且叶子节点中的数据保证逻辑上的顺序。<br>
__辅助索引__：一张表可以有多个辅助索引，叶子节点中聚集索引的主键，查询辅助索引的过程一般是先查询辅助索引的B+树，先查到主键，再根据主键去聚集索引中查询真正的数据。<br>
在其他数据库中辅助索引的叶子节点中可能存储指向数据的指针，但是这样有个缺点，在OLTP应用中，DML语句可能会使数据频繁发生移动，导致更新所有的索引，这样带来的影响是很大的（类似java中成员变量对对象的引用）。

## 0x03 管理
如果想看sql语句是否使用了索引，可以使用执行计划，__explain sql__。<br>

创建索引

		alter table tbl_name add key index_name (col_name(bytes), ...);
		create index index_name on table_name (col_name, ...);
		
删除索引

		alter table tbl_name drop key index_name;
		drop index index_name on tbl_name; 
		
mysql5.5之前创建索引的过程会新建一张表，然后将数据拷贝到新的表并且重新创建索引。<br>
innodb 1.0.x提供了一个方式FIC(Fast Insert Creation)，给表加share锁创建索引，这样就省去了创建新表拷贝数据带来的性能上的损耗，删除索引的时候只需标注该块空间可用即可。<br>
mysql5.6开始提供了新的方式OSC(Online Schema Creation)，创建和原始表一样定义的表，删除索引，然后开始拷贝数据，如果有对原表的DML操作写入delta表中，等数据拷完后在新表上重新播放次delta表中的操作，最后重建索引。这个方式的好处是勿需暂停其他事务的执行，仍可以进行索引的创建。<br>

### Online DDL

		alter table tbl_name add key index_name (col_name, ...)
		algorithm = [default | inplace | copy]
		lock = [default | none | shared | exclusive]
		
__algorithm__：copy是按照mysql5.1之前的算法來，inplace是指创建索引勿需创建新表，default是指根据old_alter_table参数来选择。<br>
__lock__：none就是不加锁，读写事务不被阻塞，share和FIC一致可以并发读，但是阻塞写，exclusive是指对表加上X锁，读写都无法并行进行，default会根据none->share->exclusive的顺序来进行选择。<br><br>

Online DDL的delta操作将这些操作放在缓存中，缓存的大小根据innodb_online_alter_log_max_size控制。如果超过缓冲的大小，创建索引的过程中会报error。

## 0x04 cardinality

索引的适用场景是访问少量数据，而且索引创建对列的选择是尽可能的具有高选择性。<br>
高选择性的判断是cardinality/n_row_in_table这个值尽可能的接近1，也就是列中的数据最好不重复，样本无限大。<br>

### cardinality的统计
__时机__：表中1/16的数据发生过改变或者stat_modified_counter>2000000000。（在执行一些特殊操作的时候也会触发重新统计cardinality值，比如analyze table、show table status、show index等操作）<br>
__算法__：随机取出8个数据页，然后根据下面的算法进行计算。

		(页1中节点不同记录个数 + ... + 页8中节点不同记录个数)/8*行数。
		
所以cardinality在多次统计的情况下可能发生变化。<br>
cardinality统计的调优参数：innodb_stats_persistent(是否存储统计结果，默认值off)、innodb_stats_on_metadata(是否在访问元数据的时候重新统计，默认值off)、innodb_stats_persistent_sample_pages(存储模式下的采样页数，默认值20)、innodb_stats_transient_sample_pages(默认模式下的采样页数，默认值8)。

